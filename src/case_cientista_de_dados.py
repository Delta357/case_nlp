# -*- coding: utf-8 -*-
"""case_cientista_de_dados.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1i11jowgIUhgyhpKaetkf00R8iTNa2CfB

# **Conhecimentos Subjetivos sobre Python**

**1) Diga em suas palavras (resumidamente): por que PEP 8 é importante (ou se não é, defenda seu ponto de vista) ? Na prática você utiliza ? Voce pensa o código (coda) já "em" PEP 8 ou corrige posteriormente (justifique)? (obs. Não é um requisito obrigatório pra contratação)**

R: PEP 8, que é o guia de estilo para código Python, é importante por diversos motivos. Ele estabelece diretrizes claras e consistentes para a escrita de código, facilitando a leitura, compreensão e manutenção do código-fonte. A aderência ao PEP 8 torna o código mais legível e acessível, tanto para o próprio desenvolvedor quanto para outros colaboradores que possam trabalhar no projeto.

Além disso, um código bem formatado e organizado ajuda a evitar erros e torna mais fácil a detecção e correção de problemas. No entanto, é normal que, durante o processo de desenvolvimento, pequenos desvios do PEP 8 possam ocorrer. Nesses casos, é recomendável corrigir posteriormente o código para se adequar às diretrizes do PEP 8. Isso ajuda a manter a consistência no código e a facilitar sua manutenção futura.

O PEP 8 é importante para manter um padrão de estilo de código que favoreça a legibilidade, compreensão e manutenção do código Python. Idealmente, o código deve ser pensado e escrito seguindo as diretrizes do PEP 8 desde o início, mas é possível corrigir posteriormente caso ocorram desvios.

**2) Por que python ?**

Python é uma linguagem de programação amplamente adotada e popular por uma série de razões. Aqui estão alguns motivos pelos quais Python é escolhido por muitos desenvolvedores:

1) Simplicidade e facilidade de uso: Python possui uma sintaxe clara e concisa, o que torna a linguagem fácil de aprender e entender. Sua legibilidade facilita a escrita de código, reduzindo a complexidade e o tempo necessário para desenvolver soluções.

2) Versatilidade: Python é uma linguagem versátil, adequada para uma ampla gama de domínios de aplicação. Pode ser utilizado no desenvolvimento web, análise de dados, inteligência artificial, automação de tarefas, ciência de dados, entre outros. Essa flexibilidade torna Python uma escolha popular entre programadores que desejam abordar diferentes tipos de projetos.

3) Grande comunidade e ecossistema: Python possui uma comunidade ativa e engajada, o que resulta em uma vasta quantidade de recursos, bibliotecas e frameworks disponíveis. Através do Python Package Index (PyPI), é possível acessar milhares de pacotes que facilitam o desenvolvimento de projetos e oferecem soluções pré-existentes para muitos problemas comuns.

4) Bibliotecas poderosas: Python possui uma rica coleção de bibliotecas e frameworks, que abrangem áreas como aprendizado de máquina (scikit-learn, TensorFlow), processamento de linguagem natural (NLTK, spaCy), visualização de dados (Matplotlib, Seaborn) e muito mais. Essas bibliotecas fornecem funcionalidades robustas, permitindo que os desenvolvedores acelerem o desenvolvimento de projetos complexos.

5) Compatibilidade e integração: Python é compatível com várias outras linguagens, permitindo a integração com sistemas existentes. Além disso, existem muitas ferramentas que facilitam a interoperabilidade entre Python e outras linguagens, como C/C++, Java e .NET.

6) Suporte multiplataforma: Python é uma linguagem multiplataforma, o que significa que você pode desenvolver em Python em diferentes sistemas operacionais, como Windows, macOS e Linux. Isso torna o código portátil e facilita a colaboração em equipe.

Esses são apenas alguns dos motivos pelos quais Python é amplamente utilizado e apreciado por desenvolvedores. Sua simplicidade, versatilidade, comunidade ativa e vasto ecossistema de bibliotecas são fatores que contribuem para sua popularidade e sucesso em uma variedade de aplicações.

**3) Se você pudesse dar um conselho a Guido van Rossum, qual seria?**

R: Se eu pudesse dar um conselho a Guido van Rossum, o criador da linguagem Python, seria o seguinte:

"Continue promovendo e incentivando a comunidade Python, dando suporte ao crescimento e à diversidade de desenvolvedores. Continue valorizando a simplicidade e legibilidade da linguagem, garantindo que novos recursos e atualizações não comprometam esses princípios fundamentais. Mantenha o equilíbrio entre inovação e estabilidade, buscando melhorias contínuas na linguagem e no ecossistema, ao mesmo tempo em que preserva a compatibilidade com versões anteriores. E, acima de tudo, ouça e valorize o feedback da comunidade Python, pois ela é uma fonte valiosa de ideias e perspectivas para o futuro da linguagem."

**4) O que são docstrings em Python, como usa e qual a importância?**

R: As docstrings em Python são strings de documentação inseridas como o primeiro elemento de uma função, classe, método ou módulo. Elas são usadas para descrever o propósito, comportamento e uso dessas estruturas de código. As docstrings são delimitadas por três aspas simples (''') ou três aspas duplas (''').

As docstrings podem conter informações sobre os parâmetros da função, o valor de retorno, exemplos de uso e qualquer outra informação relevante que ajude os desenvolvedores a entenderem e utilizarem corretamente a função.

A importância das docstrings está relacionada à documentação do código. Elas servem como uma forma de fornecer informações claras e concisas sobre a finalidade e a forma de uso de uma função, classe, método ou módulo. As docstrings facilitam a compreensão do código, tanto para o próprio desenvolvedor quanto para outros colaboradores que possam trabalhar no projeto. Além disso, elas são utilizadas por ferramentas de documentação automática, como o Sphinx, para gerar documentação mais elaborada a partir do código-fonte.

Ao escrever docstrings, é importante seguir as convenções estabelecidas pelo PEP 257, que define as diretrizes para a escrita de docstrings em Python. Isso inclui a adoção de uma estrutura consistente, uso adequado de formatação e descrições claras e informativas.

Em resumo, as docstrings em Python são strings de documentação utilizadas para descrever funções, classes, métodos e módulos. Elas desempenham um papel importante na documentação do código, fornecendo informações essenciais para a compreensão e o uso correto das estruturas de código.

# **5) Exemplo de docstring**
"""

def calcular_soma(a, b):
    """
    Calcula a soma de dois números e exibe o resultado.

    Args:
        a (int): O primeiro número.
        b (int): O segundo número.

    Returns:
        int: A soma dos dois números.

    Example:
        >>> calcular_soma(3, 5)
        A soma de 3 e 5 é 8.
        8
    """
    soma = a + b
    print(f"A soma de {a} e {b} é {soma}.")
    return soma

# Resultado da função
print(calcular_soma(3, 5))

"""# **Case 1**

Em um arquivo CSV contendo dados de vendas de uma empresa. Escreva um script Python que leia o arquivo e produza um relatório sumarizando as vendas por mês. Saida em PDF apresentando um relatório básico com o resultado. Mostre seu estilo de documenteção do código e aplique pep 8 ao código. (o foco é demostrar seu estilo de documentação e aplicação de pep 8.)

**Exercício 2 (intermediário) Opção - 1**
"""

import pandas as pd
import matplotlib.pyplot as plt

def generate_sales_report(pdf_file):
    """
    Lê um arquivo CSV contendo dados de vendas e produz um relatório sumarizando as vendas por mês.

    Args:
        pdf_file (str): O caminho do arquivo PDF para salvar o relatório.

    Returns:
        None
    """
    # Dados de exemplo
    sales_data = pd.DataFrame({
        'Data': ['2023-01-01', '2023-01-15', '2023-02-03', '2023-02-18', '2023-03-10'],
        'Vendas': [1000, 1500, 800, 1200, 900]
    })

    # Converte a coluna de datas para o formato apropriado
    sales_data['Data'] = pd.to_datetime(sales_data['Data'])

    # Extrai o mês de cada data
    sales_data['Mês'] = sales_data['Data'].dt.month

    # Agrupa as vendas por mês e calcula o total de vendas
    monthly_sales = sales_data.groupby('Mês')['Vendas'].sum()

    # Cria um gráfico de barras para o relatório
    plt.bar(monthly_sales.index, monthly_sales.values)
    plt.xlabel('Mês')
    plt.ylabel('Total de Vendas')
    plt.title('Relatório de Vendas por Mês')

    # Salva o gráfico como um arquivo PDF
    plt.savefig(pdf_file)

    # Fecha o gráfico
    plt.close()

    print(f"Relatório gerado e salvo em {pdf_file}.")

# Exemplo de uso do script
pdf_file = 'relatorio_vendas.pdf'

generate_sales_report(pdf_file)

"""#**Case 2**

Extraia o texto de um documento PDF e organize-o em parágrafos separados. Em seguida, use técnicas de Processamento de Linguagem Natural (NLP) para fazer correções gramaticais e semânticas e criar um resumo condensado de cada parágrafo. Guarde os resultados em um arquivo CSV, com cada linha representando um parágrafo e as colunas definidas como: 'Página Original', 'Conteúdo Original do Parágrafo' e 'Processamento e Resumo'. Use as bibliotecas da OpenAI para esta tarefa, escolhendo o modelo que oferece a melhor relação custo-benefício. Neste exercício, você não precisa se preocupar com controle de erros ou implementação de testes, o foco está na funcionalidade principal e na utilização eficiente das bibliotecas e ferramentas mencionadas.

**Exercício 2 (intermediário) Opção - 1**
"""

!pip install PyPDF2
!pip install spacy
!python -m spacy download pt_core_news_sm
!pip install pandas

import csv
import PyPDF2
import spacy
import pandas as pd

# Carregar modelo de processamento de linguagem natural
nlp = spacy.load('en_core_web_sm')

# Abrir o arquivo PDF
pdf_file = '/content/avengers-endgame-script-slug.pdf'

# Carregando arquivo
with open(pdf_file, 'rb') as file:
    pdf_reader = PyPDF2.PdfReader(file)
    num_pages = len(pdf_reader.pages)

    # Inicializar lista para armazenar os resultados
    results = []

    # Extrair o texto de cada página e processar os parágrafos
    for page_number, page in enumerate(pdf_reader.pages, 1):
        text = page.extract_text()

        # Dividir o texto em parágrafos
        paragraphs = text.split('\n\n')

        # Processar cada parágrafo
        for paragraph in paragraphs:
            # Remover quebras de linha adicionais e espaços em branco
            paragraph = paragraph.strip()

            if paragraph:
                # Processar o parágrafo usando o modelo spaCy
                doc = nlp(paragraph)

                # Criar um resumo condensado do parágrafo
                summary = ' '.join(sent.text for sent in doc.sents)

                # Armazenar os resultados
                results.append((page_number, paragraph, summary))

# Salvar os resultados em um arquivo CSV
output_file = 'resultado.csv'

# Arquivo CSV de saída
with open(output_file, 'w', newline='', encoding='utf-8') as file:
    writer = csv.writer(file)
    writer.writerow(['Página Original', 'Conteúdo Original do Parágrafo', 'Processamento e Resumo'])
    writer.writerows(results)

# Ler o arquivo CSV usando pandas
df = pd.read_csv(output_file)
print(df.head(5))

"""# **Exercício 2 (intermediário) Opção - 2**"""

!pip install PyPDF2
!pip install spacy
!pip install openai
!pip install pdfplumber
!python -m spacy download en_core_web_sm
!python -m spacy download en_core_web_md

# Importando as bibliotecas

# Importando bibliotecas carregamento arquivo
import csv
import pdfplumber
from PyPDF2 import PdfFileReader

# Importando biblioteca nlp
import spacy

# Importando biblioteca openai
import openai

# Configuração do modelo da OpenAI
openai.api_key = 'KEY'

# Usando o modelo text-davinci-003 da OpenAI.
# Os resultados são salvos em um arquivo CSV com três colunas: 'Página Original', 'Conteúdo Original do Parágrafo' e 'Processamento e Resumo'.
# Ao final, uma mensagem indicando a conclusão do processamento é exibida.

def extract_text_from_pdf(file_path):
    """
    Extrai o texto de um arquivo PDF usando a biblioteca pdfplumber.

    Args:
        file_path (str): Caminho para o arquivo PDF.

    Returns:
        str: Texto extraído do arquivo PDF.
    """
    with pdfplumber.open(file_path) as pdf:
        text = ''
        for page in pdf.pages:
            text += page.extract_text()
        return text


def process_text(text):
    """
    Processa o texto extraído de um arquivo PDF.

    Args:
        text (str): Texto extraído do arquivo PDF.

    Returns:
        list: Lista contendo tuplas com o parágrafo original, parágrafo corrigido e resumo condensado.
    """
    nlp = spacy.load('en_core_web_md')

    doc = nlp(text)

    processed_text = []

    for paragraph in doc.sents:
        original_content = paragraph.text

        # Correção gramatical e semântica usando spaCy
        corrected_content = str(paragraph)

        # Resumo condensado usando o modelo da OpenAI
        summary = openai.Completion.create(
            model='text-davinci-003',
            prompt=corrected_content,
            max_tokens=50,
            temperature=0.3,
            stop=None,
            n=1
        ).choices[0].text.strip()

        processed_text.append((original_content, corrected_content, summary))

    return processed_text

# Base dados
file_path = '/content/avengers-endgame-script-slug.pdf'

# Extração dados
text = extract_text_from_pdf(file_path)

# Commented out IPython magic to ensure Python compatibility.
# %%time
# 
# # Pré-processamento
# processed_text = process_text(text)

# Resultado final
csv_file = 'resultado.csv'

# Visualizando os dados
with open(csv_file, 'w', newline='', encoding='utf-8') as file:
    writer = csv.writer(file)
    writer.writerow(['Página Original', 'Conteúdo Original do Parágrafo', 'Processamento e Resumo'])
    writer.writerows(processed_text)

print('Processamento concluído e resultado salvo no arquivo CSV.')

